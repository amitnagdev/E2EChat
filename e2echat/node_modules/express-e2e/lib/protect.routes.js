'use strict';

/***********************************
 *** START ~ Module dependencies ***
 ***********************************/

// Global dependencies
const _ = require('lodash'),
    path = require('path');

// Project dependencies
const config = require('./config')(),
    tokenUtil = require('./utils/token'),
    cookieUtil = require('./utils/cookie'),
    crypto = require('./crypto');


/***********************************
 *** END ~ Module dependencies ***
 ***********************************/

const authHeader = 'authorization';

const xsrf = {
    cookie: 'XSRF-TOKEN',
    header: 'x-xsrf-token',
    socketCookie: 'WS-TOKEN',
    query: 'ws-token'
};

const generateSimpleNonce = (length, next) => {
    let chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz';
    length = length || 12;
    let result = '';
    for (let i = 0; i < length; ++i) {
        let rnum = Math.floor(Math.random() * chars.length);
        result += chars.substring(rnum, rnum + 1);
    }

    if (next && typeof next === 'function') {
        next(null, result);
    } else {
        return result;
    }
};

const validateToken = (req, res, callback) => {
    // Check header or url parameters or post parameters for token
    let token = req.query.token;
    let throughQueryString = token ? true : false;

    if (!token) {
        token = req.body.token || req.headers['x-access-token'] || (req.cookies && req.cookies.token);

        if (!token) {
            let bearerHeader = req.headers[authHeader];
            if (typeof bearerHeader !== 'undefined') {
                let bearer = bearerHeader.split(' ');
                token = bearer[1];
            }
        }
    }

    if (token) {
        // Verifies secret and checks expiry
        verifyToken(token, (err, decodedTokenObj) => {
            let decodedToken = decodedTokenObj || {};
            if (err || !decodedToken.userId) {
                if(req.log) {
                    req.log({ type: 'error', msg: err || 'Session invalid' });
                }
                
                if (!err) {
                    err = 'Session invalid';
                }
            } else {
                req.token = req.user = decodedToken;
                req.userId = req.user.userId;
                req.username = crypto.decrypt(req.user.username, config.db.secret);

                checkUserRoles(req, decodedToken);
                createCookie(req, res, decodedToken);    
            }

            callback(err, {
                token: decodedToken,
                throughQuery: throughQueryString
            });
        });
    } else {
        callback('No token provided');
    }
};

const encryptToken = (token) => crypto.encrypt(JSON.stringify(token), config.db.secret);

const createCookie = (req, res, decodedToken) => {
    // Refresh token
    cookieUtil.createCookie(req, res, 'token', tokenUtil.createToken(encryptToken(decodedToken)));
    // Xsrf protection using "Double Submit Cookies"
    createInsecureCookie(res, xsrf.cookie);
    // Socket xsrf protection
    protectSocketXsrf(req, res);
};

const verifyToken = (token, callback) => {
    // Verifies secret and checks expiry
    tokenUtil.verifyToken(token, (err, decodedTokenObj) => {
        let decodedToken = (decodedTokenObj || {}).user;
        if (err || !decodedToken) {
            callback(err, decodedToken);
        } else {
            callback(err, JSON.parse(crypto.decrypt(decodedToken, config.db.secret)));
        }
    });
};

const checkRole = (req, role) => {
    let user = req.user;
    return user && user.roles && user.roles.indexOf(role) > -1;
};

const createInsecureCookie = (res, cookieName) => {
    cookieUtil.createInsecureCookie(res, cookieName, generateSimpleNonce(30));
};

const protectSocketXsrf = (req, res) => {
    if (!req.cookies || !req.cookies[xsrf.socketCookie]) {
        // Xsrf protection using "Double Submit Cookies"
        createInsecureCookie(res, xsrf.socketCookie);
    }
};

const checkUserRoles = (req, user) => {
    if (user) {
        if (user.roles) {
            if (user.roles.indexOf('admin') > -1) {
                req.admin = true;
            }
        }
    }
};

const createExpiredCookie = (req, res) => {
    cookieUtil.createExpiredCookie(req, res, 'token', tokenUtil.createExpiredToken(encryptToken({expired: true})));
};

exports.createCookie = createCookie;
exports.createExpiredCookie = createExpiredCookie;

exports.authenticateSocket = (cookieString, query, next) => {
    let tokenExists = false;
    if (cookieString) {
        let cookie = cookieUtil.parse(cookieString);
        if (cookie) {
            let xsrfCookie = cookie[xsrf.socketCookie];
            if (xsrfCookie) {
                if (xsrfCookie === query[xsrf.query]) {     // Socket.io xsrf validation
                    if (cookie.token) {
                        let token = cookie.token;
                        if (token) {
                            tokenExists = true;
                            // Validates session by verifying secret and its expiry
                            verifyToken(token, (err, decodedTokenObj) => {
                                let decodedToken = decodedTokenObj || {};
                                if (err || !decodedToken.userId) {
                                    next(err || 'Session invalid');
                                } else {
                                    next(null, decodedToken);
                                }
                            });
                        }
                    }
                }
            }
        }
    }

    if (!tokenExists) {
        next('Invalid request');
    }
};

exports.checkAuthToken = (req, res, next) => {
    // Check header or url parameters or post parameters for token
    validateToken(req, res, (err, tokenObj) => {
        if (tokenObj && tokenObj.throughQuery) {
            res.redirect(req.protocol + '://' + req.hostname + (config.port ? ':' + config.port : ''));
        } else {
            next();
        }
    });
};

exports.isAuthenticated = (req, res, next) => {
    // Check header or url parameters or post parameters for token
    validateToken(req, res, (err, tokenObj) => {
        if (err) { // Unauthorized
            res.redirect(config.signin || '/signin');
        } else { // Authorized
            if (tokenObj && tokenObj.throughQuery) {
                res.redirect(req.protocol + '://' + req.hostname + (config.port ? ':' + config.port : ''));
            } else {
                next();
            }
        }
    });
};

exports.isAuthorized = (req, res, next) => {
    // Check header or url parameters or post parameters for token
    validateToken(req, res, (err, tokenObj) => {
        if (err) {
            res.status(401).send('Unauthorized');
        } else {
            // Validate xsrf
            if (!req.cookies || !req.cookies[xsrf.cookie] || !req.headers[xsrf.header] ||
                req.cookies[xsrf.cookie] !== req.headers[xsrf.header]) {
                err = 'Oops! It\'s a xsrf';

            }
            next(err);
        }
    });
};

exports.verifyBasicAuth = (req, res, next) => {
    let credentialsRegExp = /^ *(?:[Bb][Aa][Ss][Ii][Cc]) +([A-Za-z0-9\-\._~\+\/]+=*) *$/;
    let userPassRegExp = /^([^:]*):(.*)$/;

    const decodeBase64 = (str) => {
        return new Buffer(str, 'base64').toString();
    };

    // Get header
    let header = req.headers[authHeader];

    // Parse header
    let match = credentialsRegExp.exec(header || '');

    if (match) {
        // Decode user pass
        let credentials = userPassRegExp.exec(decodeBase64(match[1]));

        if (credentials) {
            if (credentials[1] === config.bearer.client_id && credentials[2] === config.bearer.client_secret) {
                return next();
            }
        }
    }

    res.statusCode = 401;
    res.setHeader('WWW-Authenticate', 'Basic realm="' + config.bearer.realm + '"');
    res.end('Access denied');
};

exports.isAdmin = (req, res, next) => {
    if (checkRole(req, 'admin')) {
        next();
    } else {
        res.status(401).send('Unauthorized');
    }
};

exports.hasAnyRole = (req, roles) => {
    let hasRole = false;
    if (roles) {
        if (!_.isArray(roles)) {
            roles = roles.split(',');
        }

        for(let role of roles) {
            hasRole = checkRole(req, role);
            if (hasRole) {
                break;
            }
        }
    }

    return hasRole;
};

exports.reloadXsrfCookie = (res) => {
    // Xsrf protection using "Double Submit Cookies"
    createInsecureCookie(res, xsrf.cookie);
};