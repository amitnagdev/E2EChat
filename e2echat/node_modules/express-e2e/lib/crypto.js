'use strict';

/***********************************
 *** START ~ Module dependencies ***
 ***********************************/

// Global dependencies
const _ = require('lodash'),
    path = require('path'),
    crypto = require('crypto');

// Project dependencies
const helper = require('./helper');


/***********************************
 *** END ~ Module dependencies ***
 ***********************************/

const defaultAlgorithm = 'aes-256-ctr';

const normalize = (bytes) => {
    return bytes.toString('base64').replace(/[^\w]/g, '');
};

exports.generateSalt = () => {
    return new Buffer(crypto.randomBytes(16).toString('base64'), 'base64');
};

exports.hashPassword = (password, salt) => {
    if (password && salt) {
        return crypto.pbkdf2Sync(password, salt, 10000, 64).toString('base64');
    } else {
        return password;
    }
};

exports.encrypt = (text, password, algorithm) => {
    algorithm = algorithm || defaultAlgorithm;

    let cipher = crypto.createCipher(algorithm, password);
    let crypted = cipher.update(text, 'utf8', 'hex');
    crypted += cipher.final('hex');
    return crypted;
};

exports.decrypt = (text, password, algorithm) => {
    algorithm = algorithm || defaultAlgorithm;

    let decipher = crypto.createDecipher(algorithm, password);
    let dec = decipher.update(text, 'hex', 'utf8');
    dec += decipher.final('utf8');
    return dec;
};

exports.generateNonce = (next) => {
    if (next && typeof next === 'function') {
        crypto.randomBytes(32, (error, bytes) => {
            if (error) {
                next(error);
            } else {
                next(null, normalize(bytes));
            }
        });
    } else {
        return normalize(crypto.randomBytes(32));
    }
};

exports.generateAlphaNumericPassword = (length, next) => {
    const chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz';
    length = length || 12;
    let result = '';
    let hasNumeric = false;
    let numeric = 9;

    for (let i = 0; i < length; ++i) {
        let rnum = Math.floor(Math.random() * chars.length);
        if (rnum <= numeric) {
            hasNumeric = true;
        }

        if (!hasNumeric && i === length - 1) {
            rnum = Math.floor(Math.random() * numeric);
        }

        result += chars.substring(rnum, rnum + 1);
    }

    if (next && typeof next === 'function') {
        next(null, result);
    } else {
        return result;
    }
};

exports.generateSimpleNonce = (length, next) => {
    const chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz';
    length = length || 12;
    let result = '';

    for (let i = 0; i < length; ++i) {
        let rnum = Math.floor(Math.random() * chars.length);
        result += chars.substring(rnum, rnum + 1);
    }

    if (next && typeof next === 'function') {
        next(null, result);
    } else {
        return result;
    }
};